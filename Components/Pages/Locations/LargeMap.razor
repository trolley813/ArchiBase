@page "/locations/{id:guid}/map"
@using Microsoft.EntityFrameworkCore
@inject ModelContext ModelContext
@inject IStringLocalizer<LargeMap> Loc
@inject IJSRuntime JSRuntime

@if (location != null)
{
    <ArchibasePageTitle Title=@($"{Loc["Large map for location"]}: {location.Name}") />

    @if (!loaded)
    {
        <RadzenStack Orientation="Orientation.Vertical" JustifyContent="JustifyContent.Center" Wrap="FlexWrap.Wrap">
    <RadzenText>@Loc["Loading data..."]</RadzenText>
    <RadzenProgressBarCircular ProgressBarStyle="ProgressBarStyle.Primary" Value="100" ShowValue="false"
        Mode="ProgressBarMode.Indeterminate" />
</RadzenStack>
    }

    <LeafletMap @ref="map" Style="width: 90%; height: 90%" OnMarkerClick="args => OnMarkerClick(args)"
        BuildingMarkers="markers">
    </LeafletMap>

}

@code
{
    bool loaded = false;
    class BuildingInfo
    {
        public Guid BuildingId { get; set; }
        public BuildingEventType? CurrentStatus { get; set; }
        public double Latitude { get; set; }
        public double Longitude { get; set; }
        public string Label { get; set; }
        public bool HasPhotos { get; set; }
    }

    [Parameter]
    public Guid Id { get; set; }

    LeafletMap map;

    Location? location;

    List<BuildingInfo> buildings = [];

    List<BuildingMarker> markers = [];

    protected override async Task OnParametersSetAsync()
    {
        location = ModelContext.Locations.FirstOrDefault(loc => loc.Id == Id);
        var buildingData = ModelContext.Buildings
        .Include(b => b.Events)
        .Include(b => b.Cards)
        .ThenInclude(c => c.StreetAddresses)
        .ThenInclude(a => a.Street)
        .Where(b => b.Location == location)
        .Select(b => new
        {
            Building = b,
            HasPhotos = ModelContext.BuildingBinds.Include(bi => bi.Building).Any(bi => bi.Building.Id == b.Id)
        })
        .AsSplitQuery()
        .ToList();

        buildings = buildingData.Select(b => new BuildingInfo
            {
                BuildingId = b.Building.Id,
                CurrentStatus = b.Building.Events.OrderBy(e => (e.Date.Date)).ThenBy(e => e.Type).LastOrDefault()?.Type,
                Latitude = b.Building.Latitude,
                Longitude = b.Building.Longitude,
                Label = String.Join("/", b.Building.ActualCard.StreetAddresses.Select(a => a.HouseNumber)),
                HasPhotos = b.HasPhotos
            })
        .ToList();
        markers = buildingData.Select(b => new BuildingMarker(b.Building) { HasPhotos = b.HasPhotos }).ToList();
    }

    protected override void OnAfterRender(bool firstRender)
    {
        if (firstRender)
        {
            loaded = false;
            double avgLat = 0.0, avgLon = 0.0;
            foreach (var b in buildings)
            {
                avgLat += b.Latitude;
                avgLon += b.Longitude;
            }
            if (buildings.Count != 0)
            {
                avgLat /= buildings.Count;
                avgLon /= buildings.Count;
                map.Center = (avgLat, avgLon);
            }
            else
            {
                map.Center = (location.Latitude, location.Longitude);
            }
            map.Zoom = 15;
            loaded = true;
            StateHasChanged();
        }

        base.OnAfterRender(firstRender);
    }

    async Task OnMarkerClick(BuildingMarker marker)
    {
        var lat = marker.Latitude;
        var lon = marker.Longitude;
        Guid? buildingId = buildings
        .FirstOrDefault(b => b.Latitude == lat && b.Longitude == lon)?.BuildingId;
        if (buildingId is not null)
        {
            await JSRuntime.InvokeVoidAsync("open", $"/buildings/{buildingId}", "_blank");
        }
    }
}